# -*- coding: utf-8 -*-
"""Integrated SCS short crash code file.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xMVxyTe_sqbFFQBCSZ5lyGRVGXfqSZxj
"""

# REAL ESTATE
def realestate(T, t_crash1, t_crash2, crashtype):
    # Parameters for the initial simulation
    sigma = 0.01     # volatility
    dt = 1                           # time step representing 1 trading day
    S0 = 100                         # initial price

    # Parameters for the crash simulation
    sigma_crash = 0.02                         # increased volatility during the crash

    # Mean-reversion parameters
    mean_reversion = 0.01                        # strength of mean reversion
    mean_level = S0*1.07                      # mean level for mean reversion
    mean_level_crash = mean_level*0.9         # mean level for mean reversion in crash

    # Initialize empty vectors
    S = np.zeros(T)
    S[0] = S0
    i = 0; j = 0;
    # -----Simulate initial real estate price using Geometric Brownian Motion with mean reversion----
    for t in range(T-1):
        if t>=t_crash1[0] and t<t_crash1[1]: # During market crash nr.1
            z = np.random.normal(0,1)  # random numbers
            mean_reversion_component = mean_reversion * (mean_level_crash - S[t])
            S[t+1] = S[t]+ mean_reversion_component * dt + sigma_crash *S[t]* np.sqrt(dt) * z

        elif t>=t_crash2[0] and t<t_crash2[1]: # During market crash nr.2
            z = np.random.normal(0,1)  # random numbers
            mean_reversion_component = mean_reversion * (mean_level_crash - S[t])
            S[t+1] = S[t]+ mean_reversion_component * dt + sigma_crash *S[t]* np.sqrt(dt) * z

        else: # recovery period
            z = np.random.normal(0, 1)  # random numbers
            mean_reversion_component = mean_reversion * (mean_level - S[t])
            S[t+1] = S[t] + mean_reversion_component * dt + sigma * S[t] * np.sqrt(dt) * z

    # ---plotting---
    #plt.plot(range(T), S, 'k-', linewidth=1, label='Housing market Price')

    # Highlight the crash period with a red vertical line
    #plt.axvline(x=int(t_crash1[0]), color='r', linestyle='-.', label='Start of Crash')
    #plt.axvline(x=int(t_crash1[1]), color='r', linestyle='--', label='End of Crash')

    #plt.axvline(x=int(t_crash2[0]), color='r', linestyle='-.')
    #plt.axvline(x=int(t_crash2[1]), color='r', linestyle='--')

    #plt.title('Simulated GBM & EMM with Mean Reversion for Real estate market with Market Crash')
    #plt.xlabel('Time (Days)')
    #plt.ylabel('Market Price')
    #plt.legend()
    #plt.show();
    return (S);

import numpy as np
import matplotlib.pyplot as plt

#### Stocks #####
def simulate_gbm(S0, mu, sigma, T, dt):
    """
    Simulate Geometric Brownian Motion trajectories.

    :param S0: Initial stock price
    :param mu: Annualized expected return
    :param sigma: Annualized volatility
    :param T: Duration time horizon in years
    :param dt: Time step in years
    :return: Simulated GBM path
    """
    N = int(T / dt)  # Number of time steps
    t = np.linspace(0, T, N)  # Time vector
    W = np.random.standard_normal(size = N)  # Wiener process (Brownian motion)
    W = np.cumsum(W) * np.sqrt(dt)  # Cumulative sum of Wiener increments
    S = S0 * np.exp((mu - 0.5 * sigma ** 2) * t + sigma * W)  # GBM formula
    return S, t


def stock_crash_sim(T, start_crash1, start_crash2, crash_type):
  # T: Total time in days
  # start_crash1 : start of crash 1
  # start_crash2 : start of crash 2
  # crash type :
  #   P1 : 2 shorts crashes (40 days each)
  #   P2 : 2 long crashes (252 days each)
  #   P3 : 1 short 1 long
  #   P4 : 1 long 1 short

  if crash_type == 'P1':
    T_crash1 = 40
    T_crash2 = 40
  elif crash_type == 'P2':
    T_crash1 = 252
    T_crash2 = 252
  elif crash_type == 'P3':
    T_crash1 = 40
    T_crash2 = 252
  elif crash_type == 'P4':
    T_crash1 = 252
    T_crash2 = 40
  else:
    return print('** Invalid crash type **')

  # Parameters for the initial simulation
  #T = 1.0                      # time horizon (1 year)
  mu = 0.08/252                  # expected return
  sigma = 0.0136                # volatility
  num_trading_days = 252
  #dt = T / num_trading_days    # time step representing 1 trading day
  S0 = 100                     # initial stock price

  # Parameters for the crash simulation
  num_crash_days = T_crash1                   # number of days the crash lasts
  T_crash = num_crash_days / 252              # crash duration in terms of year fraction
  mu_crash = -0.10/num_crash_days             # negative drift during the crash, value-loosing-[%/year]
  sigma_crash = 0.0283                        # increased volatility during the crash
  t_start_crash1 = start_crash1/252
  t_start_crash2 = start_crash2/252
  t_end_crash1 = (start_crash1+T_crash1)/252
  t_end_crash2 = (start_crash2+T_crash2)/252
  # Combined time steps
  total_days = num_trading_days + T_crash1 + T_crash2
  t = np.linspace(0, T/252, T)

  S0 = 100    # initial stock price
  num_stocks = 20

  stocks_sim = []
  for s in range(num_stocks):
    # pre crash

    pre_crash_duration = start_crash1
    prices_pre_crash, _ = simulate_gbm(S0, mu, sigma, pre_crash_duration, 1)

    # crash1
    mu_crash1 = -0.3 / T_crash1
    crash1_duration = T_crash1
    S0_crash1 = prices_pre_crash[-1]  # Starting price for crash phase
    prices_crash_1, _ = simulate_gbm(S0_crash1, mu_crash1, sigma_crash, crash1_duration, 1)

    # between crash 1 and crash 2

    between_crash_duration = start_crash2 - (start_crash1 + T_crash1)
    mu_recovery1 = 0.10/252
    S0_between_crash = prices_crash_1[-1]
    prices_between_crash, _ = simulate_gbm(S0_between_crash, mu_recovery1, sigma, between_crash_duration, 1)

    # crash2
    mu_crash2 = -0.3/T_crash2
    crash2_duration = T_crash2
    S0_crash2 = prices_between_crash[-1]
    prices_crash_2, _ = simulate_gbm(S0_crash2, mu_crash2, sigma_crash, crash2_duration, 1)

    # after crash 2
    after_crash_duration = T - (start_crash2 + T_crash2)
    mu_recovery2 = 0.10/252
    S0_after_crash = prices_crash_2[-1]
    prices_after_crash, _ = simulate_gbm(S0_after_crash, mu_recovery2, sigma, after_crash_duration, 1)

    # Combine the results for the full trajectory
    full_trajectory = np.concatenate((prices_pre_crash, prices_crash_1, prices_between_crash, prices_crash_2, prices_after_crash ))
    stocks_sim.append(full_trajectory)

  stocks_sim_array = np.array(stocks_sim)


  # Plot
  #plt.figure(figsize=(12, 6))
  # Add the average line
  #average_stock_price = np.mean(stocks_sim_array.T, axis=1)
  #plt.plot(t, average_stock_price, 'k-', linewidth=4, label='Average Stock Price')
  # Highlight the crash period with a red vertical line
  #plt.axvline(x=t_start_crash1, color='r', label='Start of Crash1')
  #plt.axvline(x=t_end_crash1, color='r', linestyle='--', label='End of Crash1')
  #plt.axvline(x=t_start_crash2, color='r', label='Start of Crash2')
  #plt.axvline(x=t_end_crash2, color='r', linestyle='--', label='End of Crash2')
  #plt.legend()
  #plt.plot(t,stocks_sim_array.T)
  #plt.title('Simulated Geometric Brownian Motion for 20 Stocks with Market Crash')
  #plt.xlabel("Years")
  #plt.ylabel("Stock Price")
  #plt.show()


  return stocks_sim_array

# ---------------- Bonds ----------------
def getBonds(T, start_crash1, start_crash2, crash_type):
    # This function will return Bonds graphs and a vector of the prices for each timestep, ready to be used for portfolios.

    # T: Total time in days (1 year)
    # start_crash1: Start of Crash1
    # start_crash2: Start of Crash2
    # crash_type: P1: 2 shorts crashes (40 days each)
    #             P2: 2 long crashes   (252 days each)
    #             P3: 1 short 1 long
    #             P4: 1 long 1 short

    if crash_type=='P1':
        T_crash1 = 40
        T_crash2 = 40
    elif crash_type=='P2':
        T_crash1 = 252
        T_crash2 = 252
    elif crash_type=='P3':
        T_crash1 = 40
        T_crash2 = 252
    elif crash_type=='P4':
        T_crash1 = 252
        T_crash2 = 40
    else:
        print('Invalid crash type!!!')


    # Constants and Parameters
    dt = 1                  # Time step (1 day)
    end_crash1 = start_crash1 + T_crash1  # End of Crash1
    end_crash2 = start_crash2 + T_crash2  # End of Crash2

    # Parameters for normal scenario
    a_normal = 0.1          # Speed of reversion
    b_normal = 0.01         # Long term mean level
    sigma_normal = 0.02     # Volatility
    r0 = 0.01               # Initial interest rate

    # Parameters for crash scenarios
    a_crash = 0.95          # Modified speed of reversion during crash
    b_crash = 0.07          # Modified long term mean level during crash
    sigma_crash = 0.07      # Increased volatility during crash

    # Total time steps
    N_total = int(T / dt)

    # Vasicek model functions
    def A(t, T, a):
        return (1 - np.exp(-a * (T - t))) / a

    def D(t, T, a, b, sigma):
        G = (b - ((sigma**2) / (2*a**2)))
        H = (((sigma**2) * (A(t, T, a)**2)) / (4*a))
        return G * (A(t, T, a) - (T-t)) - H

    def bond_price(A, D, rt):
        return np.exp(-A * rt + D)

    def simulate_interest_rate_path(r0, dt, N_total, start_crash1, start_crash2):
        rates = np.zeros(N_total)
        rates[0] = r0
        for t in range(1, N_total):
            if start_crash1 <= t < end_crash1 or start_crash2 <= t < end_crash2:
                a, b, sigma = a_crash, b_crash, sigma_crash
            else:
                a, b, sigma = a_normal, b_normal, sigma_normal

            Wt = np.random.normal() * np.sqrt(dt/T)
            dr = a * (b - rates[t-1]) * dt/T + sigma * Wt
            rates[t] = rates[t-1] + dr
        return rates

    sum_bond_prices = np.zeros(N_total)
    # Plotting bond prices
    #fig1, ax1 = plt.subplots(figsize=(12, 5))
    num_bonds = 10
    for _ in range(num_bonds):
        interest_rates = simulate_interest_rate_path(r0, dt, N_total, start_crash1, start_crash2)
        bond_prices = np.array([bond_price(A(t*dt/T, T/T, a_normal),
                                        D(t*dt/T, T/T, a_normal, b_normal, sigma_normal), rt)
                                for t, rt in enumerate(interest_rates)])
        sum_bond_prices += bond_prices

        # Plot bonds
        #ax1.plot(range(N_total), bond_prices)

    #ax1.axvline(x=start_crash1, color='r', linestyle='--', label='Start of Crash 1')
    #ax1.axvline(x=end_crash1, color='r', linestyle=':', label='End of Crash 1')
    #ax1.axvline(x=start_crash2, color='g', linestyle='--', label='Start of Crash 2')
    #ax1.axvline(x=end_crash2, color='g', linestyle=':', label='End of Crash 2')
    #ax1.set_title('Simulated Bond Prices Paths')
    #ax1.set_xlabel('Time (trading days)')
    #ax1.set_ylabel('Bond price')
    #ax1.legend()

    #plt.tight_layout()
    #plt.show()

    mean_bond_prices = sum_bond_prices / num_bonds
    return mean_bond_prices

#### Commodities #####
def simulate_gbm(S0, mu, sigma, T, dt):
    """
    Simulate Geometric Brownian Motion trajectories.

    :param S0: Initial stock price
    :param mu: Annualized expected return
    :param sigma: Annualized volatility
    :param T: Duration time horizon in years
    :param dt: Time step in years
    :return: Simulated GBM path
    """
    N = int(T / dt)  # Number of time steps
    t = np.linspace(0, T, N)  # Time vector
    W = np.random.standard_normal(size = N)  # Wiener process (Brownian motion)
    W = np.cumsum(W) * np.sqrt(dt)  # Cumulative sum of Wiener increments
    S = S0 * np.exp((mu - 0.5 * sigma ** 2) * t + sigma * W)  # GBM formula
    return S, t


def commodities_crash_sim(T, start_crash1, start_crash2, crash_type):
  # T: Total time in days
  # start_crash1 : start of crash 1
  # start_crash2 : start of crash 2
  # crash type :
  #   P1 : 2 shorts crashes (40 days each)
  #   P2 : 2 long crashes (252 days each)
  #   P3 : 1 short 1 long
  #   P4 : 1 long 1 short

  if crash_type=='P1':
        T_crash1 = 40
        T_crash2 = 40
  elif crash_type=='P2':
      T_crash1 = 252
      T_crash2 = 252
  elif crash_type=='P3':
      T_crash1 = 40
      T_crash2 = 252
  elif crash_type=='P4':
      T_crash1 = 252
      T_crash2 = 40
  else:
      print('Invalid crash type!!!')

  # Parameters for the initial simulation
  #T = 1.0                      # time horizon (1 year)
  mu = 0.08/252                  # expected return
  sigma = 0.0136                # volatility
  num_trading_days = 252
  #dt = T / num_trading_days    # time step representing 1 trading day
  S0 = 100                     # initial stock price

  # Parameters for the crash simulation
  num_crash_days = T_crash1                   # number of days the crash lasts
  T_crash = num_crash_days / 252              # crash duration in terms of year fraction
  mu_crash = -0.10/num_crash_days             # negative drift during the crash, value-loosing-[%/year]
  sigma_crash = 0.0283                        # increased volatility during the crash
  t_start_crash1 = start_crash1/252
  t_start_crash2 = start_crash2/252
  t_end_crash1 = (start_crash1+T_crash1)/252
  t_end_crash2 = (start_crash2+T_crash2)/252
  # Combined time steps
  total_days = num_trading_days + T_crash1 + T_crash2
  t = np.linspace(0, T/252, T)

  S0 = 100    # initial stock price
  commodities = ["Gold","Crude oil","Silver","Copper","Natural Gas","Corn","Oat"]
  num_commodities = len(commodities)
  # sigma before crash
  vol_gold_before = 0.0143
  vol_crudeoil_before = 0.0223
  vol_silver_before = 0.0232
  vol_copper_before = 0.0201
  vol_naturalgas_before = 0.0268
  vol_corn_before = 0.0211
  vol_oat_before = 0.0206

    # sigma during crash
  vol_gold_after = 0.0188
  vol_crudeoil_after = 0.0471
  vol_silver_after = 0.0327
  vol_copper_after = 0.0356
  vol_nataralgas_after = 0.0411
  vol_corn_after = 0.0290
  vol_oat_after = 0.0287
  sigma = [vol_gold_before,vol_crudeoil_before,vol_silver_before,vol_copper_before,vol_naturalgas_before,vol_corn_before,vol_oat_before]
  sigma_crash = [vol_gold_after,vol_crudeoil_after,vol_silver_after,vol_copper_after,vol_nataralgas_after,vol_corn_after,vol_oat_after]

  commodities_sim = []
  for i,commodity in enumerate(commodities):
    # pre crash

    pre_crash_duration = start_crash1
    prices_pre_crash, _ = simulate_gbm(S0, mu, sigma[i], pre_crash_duration, 1)

    # crash1
    mu_crash1 = -0.3 / 252
    crash1_duration = T_crash1
    S0_crash1 = prices_pre_crash[-1]  # Starting price for crash phase
    prices_crash_1, _ = simulate_gbm(S0_crash1, mu_crash1, sigma_crash[i], crash1_duration, 1)

    # between crash 1 and crash 2

    between_crash_duration = start_crash2 - (start_crash1 + T_crash1)
    mu_recovery1 = 0.10/252
    S0_between_crash = prices_crash_1[-1]
    prices_between_crash, _ = simulate_gbm(S0_between_crash, mu_recovery1, sigma[i], between_crash_duration, 1)

    # crash2
    mu_crash2 = -0.3/252
    crash2_duration = T_crash2
    S0_crash2 = prices_between_crash[-1]
    prices_crash_2, _ = simulate_gbm(S0_crash2, mu_crash2, sigma_crash[i], crash2_duration, 1)

    # after crash 2
    after_crash_duration = T - (start_crash2 + T_crash2)
    mu_recovery2 = 0.10/252
    S0_after_crash = prices_crash_2[-1]
    prices_after_crash, _ = simulate_gbm(S0_after_crash, mu_recovery2, sigma[i], after_crash_duration, 1)

    # Combine the results for the full trajectory
    full_trajectory = np.concatenate((prices_pre_crash, prices_crash_1, prices_between_crash, prices_crash_2, prices_after_crash ))
    commodities_sim.append(full_trajectory)

  commodities_sim_array = np.array(commodities_sim)


  # Plot
  #plt.figure(figsize=(12, 6))
  # Add the average line
  #average_commodities_price = np.mean(commodities_sim_array.T, axis=1)
  #plt.plot(t, average_commodities_price, 'k-', linewidth=4, label='Average Stock Price')
  # Highlight the crash period with a red vertical line
  #plt.axvline(x=t_start_crash1, color='r', label='Start of Crash1')
  #plt.axvline(x=t_end_crash1, color='r', linestyle='--', label='Start of Crash1')
  #plt.axvline(x=t_start_crash2, color='g', label='Start of Crash2')
  #plt.axvline(x=t_end_crash2, color='g', linestyle='--', label='Start of Crash2')

  #plt.plot(t,commodities_sim_array.T)
  #for i,commodity in enumerate(commodities):
  #  plt.plot(t, commodities_sim_array[i,:].T, label = commodity)
  #plt.title('Simulated Geometric Brownian Motion for Commodities with Market Crash')
  #plt.legend()
  #plt.xlabel("Years")
  #plt.ylabel("Commodity Price")
  #plt.show()

  return commodities_sim_array

#### Stocks #####
def simulate_gbm(S0, mu, sigma, T, dt):
    """
    Simulate Geometric Brownian Motion trajectories.

    :param S0: Initial stock price
    :param mu: Annualized expected return
    :param sigma: Annualized volatility
    :param T: Duration time horizon in years
    :param dt: Time step in years
    :return: Simulated GBM path
    """
    N = int(T / dt)  # Number of time steps
    t = np.linspace(0, T, N)  # Time vector
    W = np.random.standard_normal(size = N)  # Wiener process (Brownian motion)
    W = np.cumsum(W) * np.sqrt(dt)  # Cumulative sum of Wiener increments
    S = S0 * np.exp((mu - 0.5 * sigma ** 2) * t + sigma * W)  # GBM formula
    return S, t


def cash_crash_sim(T, start_crash1, start_crash2, crash_type):
  # T: Total time in days
  # start_crash1 : start of crash 1
  # start_crash2 : start of crash 2
  # crash type :
  #   P1 : 2 shorts crashes (40 days each)
  #   P2 : 2 long crashes (252 days each)
  #   P3 : 1 short 1 long
  #   P4 : 1 long 1 short

  if crash_type == 'P1':
      T_crash1 = 40
      T_crash2 = 40
  elif crash_type == 'P2':
      T_crash1 = 252
      T_crash2 = 252
  elif crash_type == 'P3':
      T_crash1 = 40
      T_crash2 = 252
  elif crash_type == 'P4':
      T_crash1 = 252
      T_crash2 = 40
  else:
      print('Invalid crash type!!!')

  # Parameters for the initial simulation
  #T = 1.0                      # time horizon (1 year)
  mu = 0.6333 /100 /252             # expected return : average interest rate in 10 years from 2006 - 2016
  mu_crash = 0.6333 /100 /252       # expected return during crash :
  sigma = 0.0                   # volatility of cash  is zero
  #dt = T / num_trading_days    # time step representing 1 trading day
  S0 = 100                      # initial cash value

  # Parameters for the crash simulation
  sigma_crash = 0.0                           ## volatility of cash  is zero
  t_start_crash1 = start_crash1/252
  t_start_crash2 = start_crash2/252
  t_end_crash1 = (start_crash1+T_crash1)/252
  t_end_crash2 = (start_crash2+T_crash2)/252
  # Combined time steps
  t = np.linspace(0, T/252, T)

  S0 = 100    # initial stock price
  num_stocks = 1

  cash_sim = []
  for s in range(num_stocks):
    # pre crash

    pre_crash_duration = start_crash1
    prices_pre_crash, _ = simulate_gbm(S0, mu, sigma, pre_crash_duration, 1)

    # crash1
    crash1_duration = T_crash1
    S0_crash1 = prices_pre_crash[-1]  # Starting price for crash phase
    prices_crash_1, _ = simulate_gbm(S0_crash1, mu_crash, sigma_crash, crash1_duration, 1)

    # between crash 1 and crash 2

    between_crash_duration = start_crash2 - (start_crash1 + T_crash1)
    S0_between_crash = prices_crash_1[-1]
    prices_between_crash, _ = simulate_gbm(S0_between_crash, mu, sigma, between_crash_duration, 1)

    # crash2
    crash2_duration = T_crash2
    S0_crash2 = prices_between_crash[-1]
    prices_crash_2, _ = simulate_gbm(S0_crash2, mu_crash, sigma_crash, crash2_duration, 1)

    # after crash 2
    after_crash_duration = T - (start_crash2 + T_crash2)
    S0_after_crash = prices_crash_2[-1]
    prices_after_crash, _ = simulate_gbm(S0_after_crash, mu, sigma, after_crash_duration, 1)

    # Combine the results for the full trajectory
    full_trajectory = np.concatenate((prices_pre_crash, prices_crash_1, prices_between_crash, prices_crash_2, prices_after_crash ))
    cash_sim.append(full_trajectory)

  cash_sim_array = np.array(cash_sim)


  # Plot
  #plt.figure(figsize=(12, 6))
  # Add the average line
  #average_stock_price = np.mean(cash_sim_array.T, axis=1)
  #plt.plot(t, average_stock_price, 'k-', linewidth=4, label='Average Stock Price')
  # Highlight the crash period with a red vertical line
  #plt.axvline(x=t_start_crash1, color='r', label='Start of Crash1')
  #plt.axvline(x=t_end_crash1, color='r', linestyle='--', label='End of Crash1')
  #plt.axvline(x=t_start_crash2, color='r', label='Start of Crash2')
  #plt.axvline(x=t_end_crash2, color='r', linestyle='--', label='End of Crash2')
  #plt.legend()
  #plt.plot(t,cash_sim_array.T)
  #plt.title('Simulated Geometric Brownian Motion for cash with Market Crash')
  #plt.xlabel("Years")
  #plt.ylabel("Cash Value")
  #plt.show()


  return cash_sim_array

# ------------- PORTFOLIOS -------------
import numpy as np
import matplotlib.pyplot as plt
import math

# ------------- PARAMETERS ----------------
# -------General global variables-----------
crashtype = 'P4'                       # P1: short crashes, P2: long crashes, P3: first short, then long, P4: first long, then short
num_trading_days = 252                 # number of trading days per year
T = 10*num_trading_days                # time horizon (10 years)

# number of days the crash lasts
if crashtype == 'P1':     # short crashes
    T_crash = [40, 40]
    crash_color1 = 'red'
    crash_color2 = 'red'
    crash_label1 = r'Short-Term Crash Period'
    crash_label2 = r'Short-Term Crash Period'
elif crashtype == 'P2':   # long crashes
    T_crash = [252, 252]
    crash_color1 = 'darkorange'
    crash_label1 = r'Long-Term Crash Period'
    crash_color2 = 'darkorange'
    crash_label2 = r'Long-Term Crash Period'
elif crashtype == 'P3':   # 1 short 1 long crash
    T_crash = [40, 252]
    crash_color1 = 'red'
    crash_label1 = r'Short-Term Crash Period'
    crash_color2 = 'darkorange'
    crash_label2 = r'Long-Term Crash Period'
elif crashtype == 'P4':   # 1 short 1 long crash
    T_crash = [252, 40]
    crash_color1 = 'darkorange'
    crash_label1 = r'Long-Term Crash Period'
    crash_color2 = 'red'
    crash_label2 = r'Short-Term Crash Period'

# When the crashes occur.
t_crash1=[num_trading_days, int(num_trading_days+T_crash[0])]
t_crash2=[7*num_trading_days, int(7*num_trading_days+T_crash[1])]

plt.rcParams['mathtext.fontset'] = 'cm'
plt.rcParams['font.family'] = 'STIXGeneral'

# ------------- FUNCTIONS ----------------
commodities_prices = np.mean(commodities_crash_sim(T, t_crash1[0], t_crash2[0], crashtype).T, axis=1)
cash_prices = cash_crash_sim(T, t_crash1[0], t_crash2[0], crashtype).T.reshape(-1)
stock_prices = np.mean(stock_crash_sim(T, t_crash1[0], t_crash2[0], crashtype).T, axis=1)
bond_prices = 100*getBonds(T, t_crash1[0], t_crash2[0], crashtype)
bond_prices += 100 - bond_prices[0]
real_estate_prices = realestate(T, t_crash1, t_crash2, crashtype)

plt.figure(figsize=(15, 7))

# Graph
wallet1 = 0.6  * bond_prices + 0.1  * stock_prices  + 0.1  * real_estate_prices  + 0.1 * cash_prices  + 0.1 * commodities_prices
wallet2 = 0.35 * bond_prices + 0.35 * stock_prices  + 0.1  * real_estate_prices  + 0.1 * cash_prices  + 0.1 * commodities_prices
wallet3 = 0.2  * bond_prices + 0.5  * stock_prices  + 0.1  * real_estate_prices  + 0.1 * cash_prices  + 0.1 * commodities_prices
wallet4 = 0.05 * bond_prices + 0.75 * stock_prices  + 0.05 * real_estate_prices  + 0.05 * cash_prices + 0.1  * commodities_prices

plt.plot(range(len(bond_prices)), wallet1, color='green', label=r'Conservative Portfolio')
plt.plot(range(len(bond_prices)), wallet2, color='royalblue', label=r'Balanced Portfolio')
plt.plot(range(len(bond_prices)), wallet3, color='orange', label=r'Aggressive Portfolio')
plt.plot(range(len(bond_prices)), wallet4, color='red', label=r'Growth Portfolio')

# Highlighting the crash period
plt.axvspan(int(t_crash1[0]), int(t_crash1[1]), facecolor=crash_color1, alpha=0.35, label=crash_label1)
plt.axvspan(int(t_crash2[0]), int(t_crash2[1]), facecolor=crash_color2, alpha=0.35, label=crash_label2)

plt.xlabel(r'Trading Days', fontsize=15)
plt.xlim(0,2520)
plt.ylabel(r'Value', fontsize=15)
plt.title(f'Portfolio Values over {T} Trading Days (10 years)', fontsize=18)

# Adding a secondary x-axis to show years
ax2 = plt.gca().secondary_xaxis('top')
trading_days = np.arange(0, T+1, 252)
years = trading_days / 252
ax2.set_xticks(trading_days)
ax2.set_xticklabels([str(int(year)) for year in years])
ax2.set_xlabel('Years')

plt.legend(loc='upper left', fontsize=13)

plt.show()





# def calculate_recovery_time(wallet, crash_start, crash_end):
#     pre_crash_value = wallet[crash_start - 1]
#     recovery_time = None
#     for j in range(crash_end, len(wallet)):
#         if wallet[j] >= pre_crash_value:
#             recovery_time = j - crash_end
#             break
#     return recovery_time

# crash_start = 252
# crash_end = 252 + 252

# recovery_times = [
#     calculate_recovery_time(wallet1, crash_start, crash_end),
#     calculate_recovery_time(wallet2, crash_start, crash_end),
#     calculate_recovery_time(wallet3, crash_start, crash_end),
#     calculate_recovery_time(wallet4, crash_start, crash_end)
# ]

# average_returns = [
#     (wallet[-1] - wallet[0]) / wallet[0] for wallet in [wallet1, wallet2, wallet3, wallet4]
# ]

# # (x, y) positions for each scatter point, to save the data below
# for x, y in zip(average_returns, recovery_times):
#     print(f"{x},{y}")

# import matplotlib.pyplot as plt

# # Short crash data
# groups = [
#     [(0.1605717846575882, 353), (0.24853170641916894, 480), (0.30129870555225524, 654), (0.3897234975232518, 666)],
#     [(0.5409226552996599, 469), (0.5658519516845169, 624), (0.580830656627836, 647), (0.5893288182274089, 798)],
#     [(0.15917061849389988, 1154), (0.17659866020740414, 1294), (0.18708556836766677, 1338), (0.20125582125707278, 1360)],
#     [(0.18453356831416032, 653), (0.35888069513893817, 857), (0.4633279448233854, 898), (0.6217995317373198, 925)],
#     [(0.13038182071529827, 250), (0.2188662731380076, 324), (0.27197592249889346, 327), (0.3526582973450088, 329)]
# ]

# # Long crash data
# new_groups = [
#     [(0.27775602302654423, 420), (0.35337588870516645, 538), (0.39877742610792616, 654), (0.4698348616749197, 685)],
#     [(0.5991324016567428, 338), (0.6811878310828167, 425), (0.7304691530321312, 887), (0.8054286379518973, 922)],
#     [(0.047484296032688667, 587), (0.04321916369354134, 879), (0.04066410206432296, 873), (0.02925073222812694, 795)],
#     [(0.05606196334079149, 715), (0.05020399553162288, 813), (0.04669157016278373, 828), (0.03227618417656421, 834)],
#     [(0.0010103551199852278, 1116), (0.033086650355096094, 1090), (0.052308438375104724, 1051), (0.07818425459535235, 1047)]
# ]

# # Initialize lists for mean values
# mean_x_values = [0, 0, 0, 0]
# mean_y_values = [0, 0, 0, 0]
# new_mean_x_values = [0, 0, 0, 0]
# new_mean_y_values = [0, 0, 0, 0]

# # Calculate mean x and y values for each position across all groups
# for i in range(4):
#     for group in groups:
#         mean_x_values[i] += group[i][0]
#         mean_y_values[i] += group[i][1]
#     mean_x_values[i] /= len(groups)
#     mean_y_values[i] /= len(groups)

# # Calculate mean x and y values for each position across all new groups
# for i in range(4):
#     for group in new_groups:
#         new_mean_x_values[i] += group[i][0]
#         new_mean_y_values[i] += group[i][1]
#     new_mean_x_values[i] /= len(new_groups)
#     new_mean_y_values[i] /= len(new_groups)

# # Create the combined scatter plot
# plt.figure(figsize=(10, 6))

# # Scatter plots for original and new data
# plt.scatter(mean_x_values, mean_y_values, color='blue', label='Short crash')
# plt.scatter(new_mean_x_values, new_mean_y_values, color='red', label='Long crash')

# # Draw lines between blue points
# for i in range(3):
#     plt.plot([mean_x_values[i], mean_x_values[i+1]], [mean_y_values[i], mean_y_values[i+1]], 'b-')

# # Draw lines between orange points
# for i in range(3):
#     plt.plot([new_mean_x_values[i], new_mean_x_values[i+1]], [new_mean_y_values[i], new_mean_y_values[i+1]], 'r-')

# plt.xlabel('Averaged Expected Return')
# plt.ylabel('Averaged Recovery Days')
# plt.title('Mean Recovery days vs return for the four portfolios')
# plt.legend()
# plt.show()











